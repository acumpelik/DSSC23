# -*- coding: utf-8 -*-
'''
Homework 1

How would you propose to generalize “z-scoring” (e.g., sub-
traction of the mean, normalization by the standard deviation) from the 1D case
to the multivariate case, where x belongs to R^D? Generate a synthetic dataset with 10^4
data points drawn from bivariate Gaussian distribution with di↵erent means and
standard deviations for both variables (e.g., x̄ 1 = 10, x̄ 2 = 1, and 1 = 2,
2 = 1), and for three di↵erent correlation coefficients (e.g., ⇢ = 0, 0.5, 0.95).
Does your proposed transformation alter the covariance matrix?

'''

import numpy as np
import matplotlib.pyplot as plt

# %%
# Implement a function for a gaussian distribution

# set a range
x = np.linspace(-10,10,1000)
mu, sigma = 0,1

p = (1/ (np.sqrt(2*np.pi*sigma**2))) * np.exp(-(1/2)*((x-mu)**2/sigma**2))

# def gaussian(x, mu, sigma):
#     '''
#     Parameters
#     ----------
#     mu : mean
#     sigma : standard deviation

#     Returns
#     -------
#     p : probability

#     '''    
#     p = (1/(np.sqrt(2*np.pi*sigma**2)))*np.exp(-(1/2)*((x-mu)^2/sigma**2))
#     return p

# test with a test dataset; this is wrong because x should actually be 
# generated by the function itself
# p = gaussian(x, 0, 1)

# plt.hist(p, bins=1000)
# plt.hist(p, bins=1000, range=x)
# plt.hist()

# verify 
# print(abs(mu-np.mean(x)))

plt.plot(x,p)

# %%
# Trying out the numpy normal distribution function

# Define the mean and the standard deviation
mu, sigma = 0,1

# Generate vals (n is determined by "size") drawn from the normal distribution
s = np.random.normal(
    loc=mu,
    scale=sigma,
    size=1000)


count, bins, ignored = plt.hist(s, 30, density=True)

# plt.plot(bins,
          # 1/(np.sqrt(2*np.pi*sigma**2) * np.exp(-1/2 *((bins-mu)**2 / sigma**2))))

plt.plot(bins, 
         1/((sigma * np.sqrt(2 * np.pi))) * np.exp( - (bins - mu)**2 / (2 * sigma**2) ),
         linewidth=2, 
         color='r')


plt.show()

# %%
'''
Homework 1

How would you propose to generalize “z-scoring” (e.g., sub-
traction of the mean, normalization by the standard deviation) from the 1D case
to the multivariate case, where x belongs to R^D?

Generate a synthetic dataset with 10^4
data points drawn from bivariate Gaussian distribution with di↵erent means and
standard deviations for both variables (e.g., x̄ 1 = 10, x̄ 2 = 1, and 1 = 2,
2 = 1), and for three di↵erent correlation coefficients (e.g., ⇢ = 0, 0.5, 0.95).
Does your proposed transformation alter the covariance matrix?

'''

# For the 1D case:
z_t = (x_t - x_bar) / sigma

# To generalize:
z_t = (x_t - x_bar) / cov
# The problem of generalizing is difficult because instead of variance, we now
# have a covariance matrix.










































































